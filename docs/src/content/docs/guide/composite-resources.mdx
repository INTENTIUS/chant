---
title: Composite Resources
description: Grouping related resources into reusable units
---

import { Code } from '@astrojs/starlight/components';
import compositeDefSrc from '../../../../../lexicons/aws/examples/core-concepts/src/composite-definition.ts?raw';
import compositeUsageSrc from '../../../../../lexicons/aws/examples/core-concepts/src/composite-usage.ts?raw';

A composite groups related resources into a single reusable unit. Instead of defining multiple related resources separately every time, you define them once as a composite and instantiate it with props.

## Defining a Composite

Use `Composite<Props>` from `@intentius/chant`. The factory function receives props and returns a record of named resources:

<Code code={compositeDefSrc} lang="typescript" title="src/composite-definition.ts" />

This defines a `LambdaService` composite that creates two resources: a role and a function.

## Using a Composite

Instantiate a composite by calling it with props:

<Code code={compositeUsageSrc} lang="typescript" title="src/composite-usage.ts" />

This produces all underlying resources with names derived from the props. The composite instance exposes its members directly, so `api.role` and `api.func` are accessible for cross-references.

## Referencing Members

Within the factory, you can reference other members directly since they're just variables in the same scope (as seen in the definition above — `role: role.arn`).

Outside the composite, access members via the instance:

```typescript
export const monitor = new _.Alarm({
  alarmName: "api-errors",
  dimensions: [{ name: "FunctionName", value: api.func.functionName }],
});
```

## When to Use Composites

Composites are useful when:

- **Multiple resources always appear together** — a function always needs a role and log destination
- **You want consistent naming** — derive all resource names from a single `name` prop
- **Cross-resource wiring is complex** — encapsulate the references inside the composite

For sharing default *property values* across resources of the same type, see [Presets](/chant/guide/presets/) instead.

Some lexicons also support **child projects** — subdirectories that build to separate output files. The parent references a child project via a lexicon-specific function (e.g. AWS `nestedStack()`), and cross-stack values are explicitly exported with `stackOutput()`. See [Multi-Stack Projects](/chant/guide/multi-stack/) for an overview.

See your lexicon's documentation for working composite examples with concrete resource types.
