---
title: Cross-File References
description: How to reference resources defined in other files
---

import { Code } from '@astrojs/starlight/components';
import storageSrc from '../../../../../lexicons/aws/examples/core-concepts/src/cross-ref-storage.ts?raw';
import policySrc from '../../../../../lexicons/aws/examples/core-concepts/src/cross-ref-policy.ts?raw';
import barrelRefSrc from '../../../../../lexicons/aws/examples/core-concepts/src/cross-ref-barrel.ts?raw';

Resources often depend on each other — a policy needs a storage resource's ARN, a function needs a table's name. chant provides two ways to reference resources across files: **direct imports** and **barrel references**.

## Direct Imports

Import a resource from another file and access its attributes:

<Code code={storageSrc} lang="typescript" title="src/cross-ref-storage.ts" />

<Code code={policySrc} lang="typescript" title="src/cross-ref-policy.ts" />

## Barrel References with `_.$.resource`

The recommended approach uses barrel references via `_.$`:

<Code code={barrelRefSrc} lang="typescript" title="src/cross-ref-barrel.ts" />

`_.$.dataBucket.arn` is equivalent to importing `dataBucket` from `./cross-ref-storage` and accessing `.arn`, but without needing to know which file defines it.

## Build-Time Resolution

Barrel references are resolved at build time, not at runtime. This means:

- `$` is not a JavaScript object — you cannot iterate over it, log it, or pass it to functions
- References to nonexistent resources produce a build error
- Circular dependencies between resources are detected and reported

## When to Use Each Approach

| Approach | Best for |
|---|---|
| Direct imports | Small projects, explicit dependencies |
| Barrel `_.$.resource` | Larger projects, many cross-file references |

Both approaches produce identical output. The choice is about code organization, not behavior.
