---
title: Cross-File References
description: How to reference resources defined in other files
---

Resources often depend on each other — a policy needs a storage resource's ARN, a function needs a table's name. chant provides two ways to reference resources across files: **direct imports** and **barrel references**.

## Direct Imports

Import a resource from another file and access its attributes:

```typescript
// src/storage.ts
import * as _ from "./_";

export const dataStore = new _.StorageType({
  name: "app-data",
});
```

```typescript
// src/policy.ts
import * as _ from "./_";
import { dataStore } from "./storage";

export const accessPolicy = new _.PolicyType({
  name: "data-access",
  target: dataStore.arn,
});
```

## Barrel References with `_.$.resource`

The recommended approach uses barrel references via `_.$`:

```typescript
// src/policy.ts
import * as _ from "./_";

export const accessPolicy = new _.PolicyType({
  name: "data-access",
  target: _.$.dataStore.arn,
});
```

`_.$.dataStore.arn` is equivalent to importing `dataStore` from `./storage` and accessing `.arn`, but without needing to know which file defines it.

## Build-Time Resolution

Barrel references are resolved at build time, not at runtime. This means:

- `$` is not a JavaScript object — you cannot iterate over it, log it, or pass it to functions
- References to nonexistent resources produce a build error
- Circular dependencies between resources are detected and reported

## When to Use Each Approach

| Approach | Best for |
|---|---|
| Direct imports | Small projects, explicit dependencies |
| Barrel `_.$.resource` | Larger projects, many cross-file references |

Both approaches produce identical output. The choice is about code organization, not behavior.
