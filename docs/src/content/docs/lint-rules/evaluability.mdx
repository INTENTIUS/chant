---
title: Evaluability Rules (EVL)
description: Rules that flag TypeScript patterns the evaluator cannot statically resolve
---

Evaluability rules flag TypeScript patterns that the chant evaluator cannot statically resolve. All evaluability rules have severity **error**.

---

## EVL001: Non-Literal Expression

Resource property values must be statically evaluable. Function calls, method calls, and other dynamic expressions are not allowed.

```typescript
// ❌ Triggers EVL001
export const bucket = new _.Resource({
  bucketName: getName(),
  tags: Object.assign({}, baseTags),
});
```

```typescript
// ✅ Fixed
const name = "my-data-bucket";
const tags = { ...baseTags, env: "prod" };

export const bucket = new _.Resource({
  bucketName: name,
  tags: tags,
});
```

---

## EVL002: Control Flow Wrapping Resources

Resource instantiation cannot appear inside control flow blocks (`if`, `for`, `while`, `switch`, `try`). Resources must be declared at the top level.

```typescript
// ❌ Triggers EVL002
if (env === "prod") {
  export const bucket = new _.Resource({
    bucketName: "prod-data",
  });
}
```

```typescript
// ✅ Fixed
export const bucket = new _.Resource({
  bucketName: "my-data",
});
```

---

## EVL003: Dynamic Property Access

Computed property access with a non-literal key cannot be evaluated statically.

```typescript
// ❌ Triggers EVL003
const region = config[key];
```

```typescript
// ✅ Fixed
const region = config["production"];
```

---

## EVL004: Spread From Non-Const Source

The spread operator requires the source to be traceable to a `const` declaration.

```typescript
// ❌ Triggers EVL004
export const bucket = new _.Resource({
  ...getDefaults(),
});
```

```typescript
// ✅ Fixed
const defaults = { versioning: true, encryption: "AES256" };

export const bucket = new _.Resource({
  ...defaults,
});
```

---

## EVL005: Block Body in resource() Callback

Callbacks passed to `resource()` must use expression body syntax. Block bodies with `return` statements cannot be statically evaluated.

```typescript
// ❌ Triggers EVL005
resource(_.Resource, (props) => {
  const name = props.name + "-data";
  return { bucketName: name };
});
```

```typescript
// ✅ Fixed — use expression body
resource(_.Resource, (props) => ({
  bucketName: props.name + "-data",
}));
```

---

## EVL007: Invalid Siblings Access

In composite resources, accessing `siblings.key.attr` where `key` does not exist in the resource map is an error.

```typescript
// ❌ Triggers EVL007
resource(_.ServiceType, (props, siblings) => ({
  role: siblings.typo.arn,
}));
```

```typescript
// ✅ Fixed
resource(_.ServiceType, (props, siblings) => ({
  role: siblings.executionRole.arn,
}));
```

---

## EVL008: Unresolvable Cross-File Reference

An imported resource reference cannot be resolved. The imported name does not exist in the source file.

```typescript
// ❌ Triggers EVL008
import { nonExistent } from "./storage";

export const fn = new ServiceType({
  bucket: nonExistent.bucketName,
});
```

```typescript
// ✅ Fixed
import { dataBucket } from "./storage";

export const fn = new ServiceType({
  bucket: dataBucket.bucketName,
});
```
