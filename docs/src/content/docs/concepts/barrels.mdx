---
title: "Barrel Files & the $ Symbol"
description: How barrels provide directory-scoped access to sibling resources
---

Barrels provide directory-scoped access to sibling resources through a `$` symbol table. They are chant's mechanism for cross-resource references within a directory — without explicit imports between every pair of files.

## The Problem

In a typical chant project, resources in the same directory often need to reference each other. Without barrels, every file would need explicit imports from its siblings:

```typescript
// service.ts
import { dataTable } from "./table";
import * as lexicon from "@intentius/chant-lexicon-<name>";

export const queryService = new lexicon.ServiceType({
  environment: {
    variables: {
      TABLE_ARN: dataTable.arn,
    },
  },
});
```

This works, but it creates tight coupling between files and requires updating imports whenever resources are added, renamed, or moved.

## The Barrel Pattern

A barrel file (conventionally named `_.ts`) re-exports the lexicon and declares a `$` symbol table that automatically includes all sibling resource exports:

```typescript
// _.ts
export * from "@intentius/chant-lexicon-<name>";
import { barrel } from "@intentius/chant";
export const $ = barrel(import.meta.dir);
```

Sibling files use `import * as _ from "./_"` to access everything in one namespace:

```typescript
// service.ts
import * as _ from "./_";

export const queryService = new _.ServiceType({
  name: "query-handler",
  environment: {
    variables: {
      TABLE_ARN: _.$.dataTable.arn,
    },
  },
});
```

`_.$.dataTable.arn` resolves to a symbolic cross-resource reference in the evaluated output.

## How Resolution Works

1. **Detect the barrel.** The evaluator encounters `export const $ = barrel(import.meta.dir)` and recognizes it as a directive to scan sibling files.
2. **Scan siblings.** All `.ts` files in the same directory are scanned, excluding barrel files, test files, and `node_modules`.
3. **Extract exports.** Each sibling file's AST is parsed, and named exports are extracted along with their types.
4. **Build the symbol table.** The result maps export names to their source files and resource types.
5. **Resolve property access.** When the evaluator encounters `$.dataTable.arn`, it looks up `dataTable` in the symbol table, finds its resource type, and resolves `arn` through the lexicon's attribute registry.

The symbol table is built once per directory and cached for the duration of the build.

## IDE Support

Barrel type declarations (`_.d.ts`) are generated alongside your `_.ts` barrel, enabling:

- Autocompletion for `$.` (lists all sibling resource exports)
- Autocompletion for `$.resource.` (lists available attributes for that resource type)
- Type errors when referencing non-existent resources or invalid attributes
- Go-to-definition navigation

## Naming Conventions

- **Barrel file:** `_.ts` by convention
- **Symbol table:** Always `$`. The evaluator requires `export const $ = barrel(import.meta.dir)`
- **`barrel()` argument:** Must be exactly `import.meta.dir`

## Nested Barrels

Each directory can have its own barrel. A barrel scans only its immediate sibling files — it does not include parent or child directory exports.

```
src/
  _.ts          <-- barrel for src/
  store.ts
  api/
    _.ts        <-- barrel for src/api/
    service.ts
    role.ts
```

`src/api/_.ts`'s `$` includes `service` and `role` but not `store`. To reference `store` from `src/api/service.ts`, use an explicit import.

## Edge Cases

**Circular references** between sibling resources work correctly. The evaluator builds the full symbol table before resolving any references.

**Conflicting export names** (two sibling files exporting the same name) are caught by the type checker as a duplicate export error.

**Empty barrels** produce an empty symbol table. Accessing `$.anything` produces a clear error.

**Default exports** are not included in barrel scanning. Only named exports are recognized. Use `export const name = ...` rather than `export default ...`.
